<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <!--mathjax-->
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <title>Metal documentation - Pointers</title>

    <link rel="stylesheet" href="/metal/css/styles.css">
    <link rel="stylesheet" href="/metal/css/custom.css">
    <link rel="stylesheet" href="/metal/css/syntax.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
  </head>
  <body>
    <div id="container">
      <div id="header">
	
	<div id="toolbox">
	  <table id="tooltable">
	    <tr><td class="label">Source:</td><td class="link"><a href="https://github.com/denisrosset/metal">Github</a></td></tr>
	    
	    <tr><td class="label">Chat:</td><td class="link"><a href="https://gitter.im/denisrosset/metal">Gitter</a></td></tr>
	    
	    
	    <tr><td class="label">Api:</td><td class="link"><a href="/metal/latest/api">Scaladoc</a></td></tr>
	  </table>
	</div>
	<div id="banner">
          <h1>Metal</h1>
	</div>
      </div>
      <div id="wrapper">
	<div id="navbar">
	  <ul>
	    <li  class="inactive" >
	      <a href="/metal/index.html">About</a>
	    </li>
	    <li  class="inactive">
	      <a href="/metal/contributing.html">Contributing</a>
	    </li>
	    <li  class="active" >
	      <a href="/metal/tutorials.html">Tutorials</a>
	    </li>
	    <li  class="inactive" >
	      <a href="/metal/colophon.html">Colophon</a>
	    </li>
	  </ul>
	</div>
	<div id="content">
          <h1 id="pointers">Pointers</h1>

<p>Metal defines two pointer types, <code class="highlighter-rouge">Ptr</code> and <code class="highlighter-rouge">VPtr</code>. The <code class="highlighter-rouge">Ptr</code> pointer can either point
to an element in a container, or be a null pointer. The <code class="highlighter-rouge">VPtr</code> pointer is guaranteed to point
to an element.</p>

<p>Pointers are invalidated when the container is modified, with the exception of the 
<code class="highlighter-rouge">removeAndAdvance</code> methods.</p>

<p>A pointer has a single type parameters, representing the singleton type of the pointed collection. Pointers
are implemented using value classes containing a primitive <code class="highlighter-rouge">Long</code>.</p>

<p>Most of the container methods return possibly null <code class="highlighter-rouge">Ptr</code> instances. To convert a <code class="highlighter-rouge">Ptr</code>
to a <code class="highlighter-rouge">VPtr</code>, the following syntax is encouraged:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">metal._</span>
<span class="k">import</span> <span class="nn">metal._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">container</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">container</span><span class="k">:</span> <span class="kt">metal.mutable.HashSet.S</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="n">container</span><span class="o">.</span><span class="n">ptr</span>
<span class="n">p</span><span class="k">:</span> <span class="kt">metal.Ptr</span><span class="o">[</span><span class="kt">container.</span><span class="k">type</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Ptr</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">p</span> <span class="k">match</span> <span class="o">{</span>
     <span class="o">|</span>   <span class="k">case</span> <span class="nc">IsVPtr</span><span class="o">(</span><span class="n">vp</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>     <span class="c1">// now `vp` is a `VPtr`
</span>     <span class="o">|</span>     <span class="n">println</span><span class="o">(</span><span class="n">vp</span><span class="o">.</span><span class="n">key</span><span class="o">)</span>
     <span class="o">|</span>   <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
     <span class="o">|</span>     <span class="n">println</span><span class="o">(</span><span class="s">"container is empty"</span><span class="o">)</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="mi">1</span>
</code></pre>
</div>

<p>Thanks to name-based extractors, the code snippet above does not perform any allocations.</p>

<p>Several methods are implemented on <code class="highlighter-rouge">Ptr</code> and <code class="highlighter-rouge">VPtr</code>, and can be used to access the pointed
element.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">metal._</span>
<span class="k">import</span> <span class="nn">metal._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">metal.syntax._</span>
<span class="k">import</span> <span class="nn">metal.syntax._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">HashMap</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">m</span><span class="k">:</span> <span class="kt">metal.mutable.HashMap.M</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="c1">// we request a pointer to the first element in the map (hash maps have an internal arbitrary order)
</span>     <span class="o">|</span> <span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ptr</span>
<span class="n">p</span><span class="k">:</span> <span class="kt">metal.Ptr</span><span class="o">[</span><span class="kt">m.</span><span class="k">type</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Ptr</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">assert</span><span class="o">(!</span><span class="n">p</span><span class="o">.</span><span class="n">isNull</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">assert</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">nonNull</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">assert</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">keyOrElse</span><span class="o">(-</span><span class="mi">1</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="c1">// does not throw, `sys.error` is inlined by macros and only called when `p` is null
</span>     <span class="o">|</span> <span class="n">p</span><span class="o">.</span><span class="n">keyOrElse</span><span class="o">(</span><span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">""</span><span class="o">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="c1">// same syntax for pointed values
</span>     <span class="o">|</span> <span class="n">p</span><span class="o">.</span><span class="n">valueOrElse</span><span class="o">(-</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">p</span> <span class="k">match</span> <span class="o">{</span>
     <span class="o">|</span>   <span class="k">case</span> <span class="nc">IsVPtr</span><span class="o">(</span><span class="n">vp</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>     <span class="c1">// vp is now a non-null `VPtr`, the pointed key is available
</span>     <span class="o">|</span>     <span class="n">assert</span><span class="o">(</span><span class="n">vp</span><span class="o">.</span><span class="n">key</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
     <span class="o">|</span>     <span class="n">assert</span><span class="o">(</span><span class="n">vp</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
     <span class="o">|</span>     <span class="c1">// we can ask for a (possibly null) pointer to the next element, according
</span>     <span class="o">|</span>     <span class="c1">// to the hash map internal order
</span>     <span class="o">|</span>     <span class="k">val</span> <span class="n">nxt</span> <span class="k">=</span> <span class="n">vp</span><span class="o">.</span><span class="n">next</span>
     <span class="o">|</span>   <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
     <span class="o">|</span> <span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="c1">// we can look for keys
</span>     <span class="o">|</span> <span class="k">val</span> <span class="n">p1</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ptrFind</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">p1</span><span class="k">:</span> <span class="kt">metal.Ptr</span><span class="o">[</span><span class="kt">m.</span><span class="k">type</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Ptr</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="c1">// and the same methods are available on that pointer
</span>     <span class="o">|</span> <span class="n">assert</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="n">nonNull</span><span class="o">)</span>
</code></pre>
</div>

	</div>
      </div>
	<!--workaround of poor boolean algebra implementation (see: http://stackoverflow.com/questions/23054564/how-to-use-multiple-arguments-in-an-if-statement-with-liquid?answertab=oldest#tab-top) -->
	
	
	
	<div id="extra">
	<h5>Useful links:</h5>
	<ul>
	
	<li><a href="https://github.com/denisrosset/metal/blob/master/core/src/main/scala/metal/Ptr.scala">Source</a></li>
	
	
	<li><a href="/metal/latest/api#metal.Ptr">Scaladoc</a></li>
	
	</ul>
      </div>
      
      <div id="footer">
	<p>Last updated on <em>March 22, 2016</em></p>
      </div>
    </div>

    <script src="/metal/js/scale.fix.js" type="text/javascript"></script>
  </body>
</html>
